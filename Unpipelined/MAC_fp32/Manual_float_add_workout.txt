(+ve +ve)

0 10000011 10010101100001010010000
0 10101000 01111000110101010000000


10000011
10101000 -> 01010111 -> 01011000
    

10000011
01011000

11011011 -> 00100101        


0 10101000 101111000110101010000000
0 10000011 110010101100001010010000


101111000110101010000000
000000000000000000000000000000000000110010101100001010010000
 00111100011010101000000000000000000110010101100001010010000
 01010100001111000110101010000000
0 10101000 011 1100 0110 1010 1000 0000
           011 1100 0110 1010 1000 0000


(-ve -ve)

1 10000011 10010101100001010010000
1 10101000 01111000110101010000000

10000011 < 10101000

swap 

1 10101000 01111000110101010000000
1 10000011 10010101100001010010000


10101000
10000011 -> 01111101

10101000
01111101
00100101 -> shift amount       

101111000110101010000000
0000000000000000000000000000000000000110010101100001010010000
1011110001101010100000000000000000000110010101100001010010000
 01111000110101010000000

1 10101000 011 1100 0110 1010 1000 0000 <- obtained answer
1 10101000 011 1100 0110 1010 1000 0000 <- correct answer




(-ve +ve)

1 10000011 10010101100001010010000
0 10101000 01111000110101010000000

10000011 < 10101000

swap
0 10101000 01111000110101010000000
1 10000011 10010101100001010010000

10101000
10000011 -> 01111101

10101000
01111101
00100101              

101111000110101010000000
0000000000000000000000000000000000000110010101100001010010000 -> 1111111111111111111111111111111111111001101010011110101110000

101111000110101010000000
111111111111111111111111  1111111111111001101010011110101110000

101111000110101001111111 1 111111111111001101010011110101110000
101111000110101010000000
 01111000110101010000000
0 10101000 011 1100 0110 1010 1000 0000 <- obtained answer
0 10101000 011 1100 0110 1010 1000 0000 <- correct answer


-------------------------------------------------------------------------------------------------------------------

Testcase #8 -> 805306.375 -> 01001001010001001001101110100110
Testcase #5 -> 415236.125 -> 01001000110010101100000010000100

(+ve +ve)
0 10010010 10001001001101110100110
0 10010001 10010101100000010000100

10010010 > 10010001  

No swap
0 10010010 10001001001101110100110
0 10010001 10010101100000010000100

sign bit both same -> normal addition

10010010
10010001 -> 01101111

10010010
01101111
00000001

110001001001101110100110
0110010101100000010000100
10010100111111011111010000  (got carry so adjust exponent)            

10010010 + 1 -> 10010011

0 10010011 00101001111110111110100 <- obtained answer
0 10010011 00101001111110111110100 <- correct answer


(-ve -ve)
1 10010010 10001001001101110100110
1 10010001 10010101100000010000100

10010010 > 10010001

No swap
1 10010010 10001001001101110100110
1 10010001 10010101100000010000100


10010010
10010001 -> 01101111

10010010
01101111
00000001

sign bit both same -> normal addition

110001001001101110100110
0110010101100000010000100
10011100111111011111010000   (got carry so adjust exponent)                

10010010 + 1 -> 10010011

1 10010011 00111001111110111110100 <- obtained answer
1 10010011 00101001111110111110100 <- correct answer


(+ve -ve)
0 10010010 10001001001101110100110
1 10010001 10010101100000010000100

10010010 > 10010001

No swap
0 10010010 10001001001101110100110
1 10010001 10010101100000010000100

(Sign is different -> subtraction)

10010010
10010001 -> 01101111

10010010
01101111
00000001

110001001001101110100110
0110010101100000010000100 -> 1001101010011111101111100

110001001001101110100110
1001101010011111101111100
10101111100111011011001000 (got carry (borrow) not sure of what to do) 

Let's try to ignore borrow and see:

110001001001101110100110  -> this is bigger so take this number's sign 
0110010101100000010000100 

When borrow is ignored:
10101111100111011011001000 -> 0.101111100111011011001000 -> Denormalised so adjust exponent
1.01111100111011011001000 * 2 ^ -1

10010010 - 1 -> 11111111

10010010
11111111
10010001

0 10010001 01111100111011011001000 <- obtained answer
0 10010001 01111100111011011001000 <- correct answer





(-ve +ve)
1 10010010 10001001001101110100110
0 10010001 10010101100000010000100

10010010 > 10010001

No swap 

10010010
10010001 -> 01101111

10010010
01101111
00000001

Signs are different so subtract


110001001001101110100110
0110010101100000010000100
1001101010011111101111011                        

110001001001101110100110
1001101010011111101111100                        
0101111100111011011001000  -> Denormalised so adjust exponent          

1.01111100111011011001000 * 2^-1


10010010
11111111
10010001         


110001001001101110100110 <- This is bigger so take this exponent
0110010101100000010000100

1 10010001 01111100111011011001 <- obtained answer
1 10010001 01111100111011011001 <- correct answer



--------------------------------------------------------------------------------
AxB+C
# 1

0 10101101 110100000000000000000

0 10101101 11010000000000000000000
0 10000011 10010101100001010010000

10101101 > 10000011

10101101
10000011 -> 01111101

10101101
01111101
00101010           


111010000000000000000000
000000000000000000000000000000000000000000110010101100001010010000
111010000000000000000000000000000000000000110010101100001010010000
1.11010000000000000000000

0 10101101 11010000000000000000000 <- obtained answer
0 10101101 00110100000000000000000
-----------------------------------------------------------------------------------------------





MAC
A = 0100000100101100
B = 0101010011100101
C = 01000001110010101100001010010000

AxB 
0 10000010 0101100
0 10101001 1100101

10101001
10000010
10000001
10101100


10101100 x 11100101
           10101100
          000000000
         1010110000
        00000000000
       000000000000
      1010110000000
     10101100000000
    101011000000000
   10.01100111011100 (carry detected) adjust exponent

10101100 + 1 -> 10101101

+C
0 10101101 00110100000000000000000 
0 10000011 10010101100001010010000

10101101 > 10000011

No swap
0 10101101 00110100000000000000000 
0 10000011 10010101100001010010000


10101101
10000011 -> 01111101

10101101
01111101
00101010         

100110100000000000000000 
000000000000000000000000000000000000000000110010101100001010010000
100110100000000000000000 000000000000000000110010101100001010010000 

01010110100110100000000000000000
01010110100110100000000000000000



--------------------------------------------------------------------


0 11001001 11000000000000000000000
0 10101000 01111000110101010000000

11001001 > 10101000

No swap
11001001
10101000 -> 01011000

11001001
01011000
00100001


111000000000000000000000
000000000000000000000000000000000101111000110101010000000
111000000000000000000000 000000000101111000110101010000000

01100100111000000000000000000000
01100100111000000000000000000000

----------------------------------------------------------------------------
A = "0100100011000001"
B = "01001111100000110001001001101111"


0 10010001 10000010000000000000000
0 10011111 00000110001001001101111

10010001 < 10011111

swap
0 10011111 00000110001001001101111
0 10010001 10000010000000000000000

10011111
10010001 -> 01101111

10011111
01101111
00001110              

100000110001001001101111
00000000000000110000010000000000000000
100000110001010101110011


0 10011111 00000110001010101110011
0 10011111 00000110001010101110011
0 10011111 00000110001010101110011

--------------------------------------------------------------------------------
Multiply 

A = "0100000100100000"
B = "0011111000100011"


0 10000010 0100000
0 01111100 0100011

10000010
01111100
10000001
01111111   

101 x 10100011
        101
       1010
      00000         
     000000         
    0000000
   10100000
  000000000
 1010000000         
 1.100101111                    
   10010111100000

0 01111111 1001100
0 01111111 10010111111111111111111
0 11111111 001100

------------------------------------------------------------------------------------
Add

0 01111111 10011000000000000000000
0 01111111 11101011110001101010101


110011000000000000000000
111101011110001101010101
1110000011110001101010101

0 01111111 11000001111000110101010
0 10000000 11000001111000110101010


10011001 11011100




---------------------------------------------------------------------------------------

A = "0100000100101100"
B = "0101010011100101"

0 10000010 0101100
0 10101001 1100101


10000010
10101001
10000001
10101100       

101011 x 11100101

           101011
          0000000
         10101100
        000000000
       0000000000
      10101100000
     101011000000
    1010110000000
   10011001110111         

0 10101101 0011001110111         

---------------------------------------------------------------------------


A = "0100000100100000"
B = "0011111000100011"


0 10000010 0100000
0 01111100 0100011

10000010
01111100
10000001
01111111          


101 x 10100011

        101
       1010
      00000
     000000
    0000000
   10100000
  000000000
 1010000000
 1100101111               
0110010111100000

0 01111111 100101111               

----------------------------------------------------------------------------

A = "0100010010110111"
B = "01000111011111011111001110110111"

0 10001001 01101110000000000000000
0 10001110 11111011111001110110111


10001001 < 10001110

Swap
0 10001110 11111011111001110110111
0 10001001 01101110000000000000000

10001110
10001001 -> 01110111

10001110
01110111
00000101

111111011111001110110111
00000101101110000000000000000
100000011101010111011011100000 (Generated carry , must adjust exponent)

10001110 + 1
10001111

0 10001111 00000011101010111011010           100000
0 10001111 00000011101010111011100
0 10001111 00000011101010111011100


------------------------------------------------------------------------

A = "0101001100101110"
B = "0101010100111100"

0 10100110 0101110
0 10101010 0111100

10100110
10101010
10000001
11010001

#00101101

1010111 x 101111

        1010111
       10101110
      101011100
     1010111000
    00000000000
   101011100000
000000101010000             
   111111111001    
   111111111001000

0 11010001 1111111  1001    
0 11010010 0000000  1001  
0 11010010 00000000000000000000000  

----------------------------------------------------------------------------
# Float subtraction

0 10101101 00110100000000000000000
1 10000011 10010101100001010010000

10101101 > 10000011

no swap

10101101
10000011 -> 01111101

10101101
01111101
00101010     

100110100000000000000000
000000000000000000000000000000000000000000110010101100001010010000
100110100000000000000000000000000000000000110010101100001010010000

+ve has bigger exponent
0 10101101 00110100000000000000000 <- manual calculation
0 10101101 00110100000000000000000 <- Expected


----------------------------------------------------------------------------

0 10010001 10000010000000000000000
1 10011111 00000110001001001101111

10010001 < 10011111

swap
1 10011111 00000110001001001101111
0 10010001 10000010000000000000000

10011111
10010001 -> 01101111

10011111
01101111
00001110        

100000110001001001101111
00000000000000110000010000000000000000

2's complement
100000110001001001101111
11111111111111001111110000000000000000
10000011000011110110101100000000000000                                          

-ve had bigger exponent
1 10011111 00000110000111101101011 <- manual calculation
1 10011111 00000110000111101101011







































